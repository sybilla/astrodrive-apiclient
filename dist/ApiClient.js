"use strict";
/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const aurelia_framework_1 = require("aurelia-framework");
const aurelia_fetch_client_1 = require("aurelia-fetch-client");
let ApiClient = class ApiClient {
    constructor(baseUrl, http) {
        this.jsonParseReviver = undefined;
        this.http = http ? http : window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }
    apiVAstrometryAttachtoentry(version, entryId, astrometry) {
        let url_ = this.baseUrl + "/api/v{version}/astrometry/attachtoentry?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(astrometry);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVAstrometryAttachtoentry(_response);
        });
    }
    processApiVAstrometryAttachtoentry(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVDirectoryCreate(version, parentId, folderName, path) {
        let url_ = this.baseUrl + "/api/v{version}/directory/create?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryCreate(_response);
        });
    }
    processApiVDirectoryCreate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @param parentId (optional)
     * @param archiveName (optional)
     * @return Success
     */
    apiVDirectoryCreatearchive(version, id, parentId, archiveName) {
        let url_ = this.baseUrl + "/api/v{version}/directory/createarchive?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (archiveName !== undefined)
            url_ += "archiveName=" + encodeURIComponent("" + archiveName) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryCreatearchive(_response);
        });
    }
    processApiVDirectoryCreatearchive(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? File.fromJS(resultData200) : new File();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @param userId (optional)
     * @param path (optional)
     * @return Success
     */
    apiVDirectoryList(version, id, userId, path) {
        let url_ = this.baseUrl + "/api/v{version}/directory/list?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryList(_response);
        });
    }
    processApiVDirectoryList(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param userId (optional)
     * @param path (optional)
     * @return Success
     */
    apiVDirectoryDirectoryid(version, userId, path) {
        let url_ = this.baseUrl + "/api/v{version}/directory/directoryid?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryDirectoryid(_response);
        });
    }
    processApiVDirectoryDirectoryid(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVDirectoryBreadcrumbs(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/directory/breadcrumbs?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryBreadcrumbs(_response);
        });
    }
    processApiVDirectoryBreadcrumbs(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Breadcrumb.fromJS(item));
                }
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @return Success
     */
    apiVDirectoryListsharedroot(version) {
        let url_ = this.baseUrl + "/api/v{version}/directory/listsharedroot";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryListsharedroot(_response);
        });
    }
    processApiVDirectoryListsharedroot(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(UserInfo.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVDirectoryListshared(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/directory/listshared?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryListshared(_response);
        });
    }
    processApiVDirectoryListshared(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? UserInfo.fromJS(resultData200) : new UserInfo();
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVDirectoryGetarchiveentries(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/directory/getarchiveentries?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryGetarchiveentries(_response);
        });
    }
    processApiVDirectoryGetarchiveentries(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(PathWithId.fromJS(item));
                }
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVDirectoryUpdate(version, directory) {
        let url_ = this.baseUrl + "/api/v{version}/directory/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(directory);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryUpdate(_response);
        });
    }
    processApiVDirectoryUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVDirectoryRemove(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/directory/remove?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVDirectoryRemove(_response);
        });
    }
    processApiVDirectoryRemove(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param message (optional)
     * @param parentId (optional)
     * @param userId (optional)
     * @return Success
     */
    apiVFileUploadlink(version, message, parentId, userId) {
        let url_ = this.baseUrl + "/api/v{version}/file/uploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(message);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileUploadlink(_response);
        });
    }
    processApiVFileUploadlink(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? UploadLinkWithId.fromJS(resultData200) : new UploadLinkWithId();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param fileId (optional)
     * @param userId (optional)
     * @return Success
     */
    apiVFileConfirmupload(version, fileId, userId) {
        let url_ = this.baseUrl + "/api/v{version}/file/confirmupload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileConfirmupload(_response);
        });
    }
    processApiVFileConfirmupload(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? File.fromJS(resultData200) : new File();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVFileDownloadlink(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/downloadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileDownloadlink(_response);
        });
    }
    processApiVFileDownloadlink(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param userId (optional)
     * @param phrase (optional)
     * @param from (optional)
     * @param to (optional)
     * @return Success
     */
    apiVFileSearch(version, userId, phrase, from, to) {
        let url_ = this.baseUrl + "/api/v{version}/file/search?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (phrase !== undefined)
            url_ += "phrase=" + encodeURIComponent("" + phrase) + "&";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileSearch(_response);
        });
    }
    processApiVFileSearch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVFileInfo(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/info?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileInfo(_response);
        });
    }
    processApiVFileInfo(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? File.fromJS(resultData200) : new File();
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVFileGetsubmissions(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/getsubmissions?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileGetsubmissions(_response);
        });
    }
    processApiVFileGetsubmissions(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(WorkflowSubmissionEntry.fromJS(item));
                }
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVFileThumbnailuploadlink(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/thumbnailuploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileThumbnailuploadlink(_response);
        });
    }
    processApiVFileThumbnailuploadlink(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVFileArchiveuploadlink(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/archiveuploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileArchiveuploadlink(_response);
        });
    }
    processApiVFileArchiveuploadlink(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVFileThumbnail(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/thumbnail?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileThumbnail(_response);
        });
    }
    processApiVFileThumbnail(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVFileArchive(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/archive?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileArchive(_response);
        });
    }
    processApiVFileArchive(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? File.fromJS(resultData200) : new File();
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVFileArchiveprogress(version, id, processed, total) {
        let url_ = this.baseUrl + "/api/v{version}/file/archiveprogress?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (processed !== undefined)
            url_ += "processed=" + encodeURIComponent("" + processed) + "&";
        if (total !== undefined)
            url_ += "total=" + encodeURIComponent("" + total) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileArchiveprogress(_response);
        });
    }
    processApiVFileArchiveprogress(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVFileAttachheader(version, id, header) {
        let url_ = this.baseUrl + "/api/v{version}/file/attachheader?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(header);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileAttachheader(_response);
        });
    }
    processApiVFileAttachheader(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVFileUpdate(version, file) {
        let url_ = this.baseUrl + "/api/v{version}/file/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(file);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileUpdate(_response);
        });
    }
    processApiVFileUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVFileDelete(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/file/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVFileDelete(_response);
        });
    }
    processApiVFileDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param entryId (optional)
     * @return Success
     */
    apiVProgressGet(version, entryId) {
        let url_ = this.baseUrl + "/api/v{version}/progress/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVProgressGet(_response);
        });
    }
    processApiVProgressGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? WorkflowSubmissionEntry.fromJS(resultData200) : new WorkflowSubmissionEntry();
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVProgressLog(version, entryId, progress, msg) {
        let url_ = this.baseUrl + "/api/v{version}/progress/log?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&";
        if (progress !== undefined)
            url_ += "progress=" + encodeURIComponent("" + progress) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(msg);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVProgressLog(_response);
        });
    }
    processApiVProgressLog(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVProgressError(version, entryId, msg) {
        let url_ = this.baseUrl + "/api/v{version}/progress/error?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(msg);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVProgressError(_response);
        });
    }
    processApiVProgressError(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param start (optional)
     * @param count (optional)
     * @return Success
     */
    apiVUtilsLastuserimages(version, start, count) {
        let url_ = this.baseUrl + "/api/v{version}/utils/lastuserimages?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVUtilsLastuserimages(_response);
        });
    }
    processApiVUtilsLastuserimages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(File.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param start (optional)
     * @param count (optional)
     * @return Success
     */
    apiVUtilsLastimages(version, start, count) {
        let url_ = this.baseUrl + "/api/v{version}/utils/lastimages?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVUtilsLastimages(_response);
        });
    }
    processApiVUtilsLastimages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(File.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param userId (optional)
     * @return Success
     */
    apiVUtilsQuota(version, userId) {
        let url_ = this.baseUrl + "/api/v{version}/utils/quota?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVUtilsQuota(_response);
        });
    }
    processApiVUtilsQuota(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DiskSpaceUsage.fromJS(resultData200) : new DiskSpaceUsage();
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVUtilsChangequota(version, userId, quotaMB) {
        let url_ = this.baseUrl + "/api/v{version}/utils/changequota?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (quotaMB !== undefined)
            url_ += "quotaMB=" + encodeURIComponent("" + quotaMB) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVUtilsChangequota(_response);
        });
    }
    processApiVUtilsChangequota(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param fileId (optional)
     * @param userId (optional)
     * @return Success
     */
    apiVUtilsConfirmupload(version, fileId, userId) {
        let url_ = this.baseUrl + "/api/v{version}/utils/confirmupload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVUtilsConfirmupload(_response);
        });
    }
    processApiVUtilsConfirmupload(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? File.fromJS(resultData200) : new File();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param quotaMB (optional)
     * @return Success
     */
    apiVUtilsAdduser(version, quotaMB) {
        let url_ = this.baseUrl + "/api/v{version}/utils/adduser?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (quotaMB !== undefined)
            url_ += "quotaMB=" + encodeURIComponent("" + quotaMB) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVUtilsAdduser(_response);
        });
    }
    processApiVUtilsAdduser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param name (optional)
     * @param payload (optional)
     * @return Success
     */
    apiVWorkflowdefinitionAdd(version, name, payload) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/add?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(payload);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionAdd(_response);
        });
    }
    processApiVWorkflowdefinitionAdd(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param name (optional)
     * @param payload (optional)
     * @return Success
     */
    apiVWorkflowdefinitionAddglobal(version, name, payload) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/addglobal?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(payload);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionAddglobal(_response);
        });
    }
    processApiVWorkflowdefinitionAddglobal(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowdefinitionGetbyid(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/getbyid?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionGetbyid(_response);
        });
    }
    processApiVWorkflowdefinitionGetbyid(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? WorkflowDefinition.fromJS(resultData200) : new WorkflowDefinition();
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @return Success
     */
    apiVWorkflowdefinitionList(version) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/list";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionList(_response);
        });
    }
    processApiVWorkflowdefinitionList(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(WorkflowDefinition.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @return Success
     */
    apiVWorkflowdefinitionListglobal(version) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/listglobal";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionListglobal(_response);
        });
    }
    processApiVWorkflowdefinitionListglobal(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(WorkflowDefinition.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param definition (optional)
     * @return Success
     */
    apiVWorkflowdefinitionUpdate(version, definition) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(definition);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionUpdate(_response);
        });
    }
    processApiVWorkflowdefinitionUpdate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVWorkflowdefinitionUpdateglobal(version, definition) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/updateglobal";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(definition);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionUpdateglobal(_response);
        });
    }
    processApiVWorkflowdefinitionUpdateglobal(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowdefinitionDelete(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionDelete(_response);
        });
    }
    processApiVWorkflowdefinitionDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVWorkflowdefinitionDeleteglobal(version, configurationId) {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/deleteglobal?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (configurationId !== undefined)
            url_ += "configurationId=" + encodeURIComponent("" + configurationId) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowdefinitionDeleteglobal(_response);
        });
    }
    processApiVWorkflowdefinitionDeleteglobal(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param payload (optional)
     * @return Success
     */
    apiVWorkflowsubmissionSubmit(version, payload) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/submit";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(payload);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionSubmit(_response);
        });
    }
    processApiVWorkflowsubmissionSubmit(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? WorkflowSubmission.fromJS(resultData200) : new WorkflowSubmission();
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @return Success
     */
    apiVWorkflowsubmissionListuser(version) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/listuser";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionListuser(_response);
        });
    }
    processApiVWorkflowsubmissionListuser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(WorkflowSubmission.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionListworkflow(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/listworkflow?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionListworkflow(_response);
        });
    }
    processApiVWorkflowsubmissionListworkflow(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(WorkflowSubmission.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionGetfilesubmissionentries(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/getfilesubmissionentries?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionGetfilesubmissionentries(_response);
        });
    }
    processApiVWorkflowsubmissionGetfilesubmissionentries(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(WorkflowSubmissionEntry.fromJS(item));
                }
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionGet(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionGet(_response);
        });
    }
    processApiVWorkflowsubmissionGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? WorkflowSubmission.fromJS(resultData200) : new WorkflowSubmission();
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionEntrycancelled(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/entrycancelled?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionEntrycancelled(_response);
        });
    }
    processApiVWorkflowsubmissionEntrycancelled(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVWorkflowsubmissionCancel(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/cancel?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionCancel(_response);
        });
    }
    processApiVWorkflowsubmissionCancel(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionentryGet(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionentryGet(_response);
        });
    }
    processApiVWorkflowsubmissionentryGet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? WorkflowSubmissionEntry.fromJS(resultData200) : new WorkflowSubmissionEntry();
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionentryGetpayload(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/getpayload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionentryGetpayload(_response);
        });
    }
    processApiVWorkflowsubmissionentryGetpayload(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    apiVWorkflowsubmissionentryIscancelled(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/iscancelled?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionentryIscancelled(_response);
        });
    }
    processApiVWorkflowsubmissionentryIscancelled(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null;
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVWorkflowsubmissionentryCancel(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/cancel?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionentryCancel(_response);
        });
    }
    processApiVWorkflowsubmissionentryCancel(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    apiVWorkflowsubmissionentryDelete(version, id) {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {}
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processApiVWorkflowsubmissionentryDelete(_response);
        });
    }
    processApiVWorkflowsubmissionentryDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => _headers[k] = v);
        }
        ;
        if (status === 403) {
            return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
};
ApiClient = __decorate([
    aurelia_framework_1.inject(String, aurelia_fetch_client_1.HttpClient),
    __metadata("design:paramtypes", [String, Object])
], ApiClient);
exports.ApiClient = ApiClient;
class File {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.parentDirectoryId = data["parentDirectoryId"];
            this.id = data["id"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            this.header = data["header"];
            this.accessLevel = data["accessLevel"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : undefined;
            this.uploadedDate = data["uploadedDate"] ? new Date(data["uploadedDate"].toString()) : undefined;
            this.thumbnailAddress = data["thumbnailAddress"];
            this.extension = data["extension"];
            this.uploadCompleted = data["uploadCompleted"];
            this.size = data["size"];
            this.ownerId = data["ownerId"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(WorkflowSubmissionEntry.fromJS(item));
            }
            if (data["sharedWith"] && data["sharedWith"].constructor === Array) {
                this.sharedWith = [];
                for (let item of data["sharedWith"])
                    this.sharedWith.push(item);
            }
            this.processedFiles = data["processedFiles"];
            this.totalFiles = data["totalFiles"];
            this.locked = data["locked"];
            this.lockedBy = data["lockedBy"];
            this.mD5 = data["mD5"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["parentDirectoryId"] = this.parentDirectoryId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        data["header"] = this.header;
        data["accessLevel"] = this.accessLevel;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : undefined;
        data["uploadedDate"] = this.uploadedDate ? this.uploadedDate.toISOString() : undefined;
        data["thumbnailAddress"] = this.thumbnailAddress;
        data["extension"] = this.extension;
        data["uploadCompleted"] = this.uploadCompleted;
        data["size"] = this.size;
        data["ownerId"] = this.ownerId;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        if (this.sharedWith && this.sharedWith.constructor === Array) {
            data["sharedWith"] = [];
            for (let item of this.sharedWith)
                data["sharedWith"].push(item);
        }
        data["processedFiles"] = this.processedFiles;
        data["totalFiles"] = this.totalFiles;
        data["locked"] = this.locked;
        data["lockedBy"] = this.lockedBy;
        data["mD5"] = this.mD5;
        return data;
    }
}
exports.File = File;
class WorkflowSubmissionEntry {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.fileId = data["fileId"];
            this.workflowSubmissionId = data["workflowSubmissionId"];
            this.state = data["state"];
            this.submittedAt = data["submittedAt"] ? new Date(data["submittedAt"].toString()) : undefined;
            this.completedAt = data["completedAt"] ? new Date(data["completedAt"].toString()) : undefined;
            this.name = data["name"];
            this.error = data["error"];
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [];
                for (let item of data["stages"])
                    this.stages.push(WorkflowSubmissionEntryStage.fromJS(item));
            }
            if (data["astrometries"] && data["astrometries"].constructor === Array) {
                this.astrometries = [];
                for (let item of data["astrometries"])
                    this.astrometries.push(Astrometry.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmissionEntry();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileId"] = this.fileId;
        data["workflowSubmissionId"] = this.workflowSubmissionId;
        data["state"] = this.state;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : undefined;
        data["name"] = this.name;
        data["error"] = this.error;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        if (this.astrometries && this.astrometries.constructor === Array) {
            data["astrometries"] = [];
            for (let item of this.astrometries)
                data["astrometries"].push(item.toJSON());
        }
        return data;
    }
}
exports.WorkflowSubmissionEntry = WorkflowSubmissionEntry;
class WorkflowSubmissionEntryStage {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.progress = data["progress"];
            this.message = data["message"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmissionEntryStage();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["progress"] = this.progress;
        data["message"] = this.message;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : undefined;
        return data;
    }
}
exports.WorkflowSubmissionEntryStage = WorkflowSubmissionEntryStage;
class Astrometry {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.ra = data["ra"];
            this.dec = data["dec"];
            this.objectsCount = data["objectsCount"];
            this.rotation = data["rotation"];
            this.payload = data["payload"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Astrometry();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["ra"] = this.ra;
        data["dec"] = this.dec;
        data["objectsCount"] = this.objectsCount;
        data["rotation"] = this.rotation;
        data["payload"] = this.payload;
        return data;
    }
}
exports.Astrometry = Astrometry;
class Directory {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.parentDirectoryId = data["parentDirectoryId"];
            this.name = data["name"];
            this.accessLevel = data["accessLevel"];
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : undefined;
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(File.fromJS(item));
            }
            this.ownerId = data["ownerId"];
            this.id = data["id"];
            this.size = data["size"];
            if (data["subdirectories"] && data["subdirectories"].constructor === Array) {
                this.subdirectories = [];
                for (let item of data["subdirectories"])
                    this.subdirectories.push(Directory.fromJS(item));
            }
            if (data["sharedWith"] && data["sharedWith"].constructor === Array) {
                this.sharedWith = [];
                for (let item of data["sharedWith"])
                    this.sharedWith.push(item);
            }
            this.locked = data["locked"];
            this.lockedBy = data["lockedBy"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Directory();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["parentDirectoryId"] = this.parentDirectoryId;
        data["name"] = this.name;
        data["accessLevel"] = this.accessLevel;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : undefined;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["ownerId"] = this.ownerId;
        data["id"] = this.id;
        data["size"] = this.size;
        if (this.subdirectories && this.subdirectories.constructor === Array) {
            data["subdirectories"] = [];
            for (let item of this.subdirectories)
                data["subdirectories"].push(item.toJSON());
        }
        if (this.sharedWith && this.sharedWith.constructor === Array) {
            data["sharedWith"] = [];
            for (let item of this.sharedWith)
                data["sharedWith"].push(item);
        }
        data["locked"] = this.locked;
        data["lockedBy"] = this.lockedBy;
        return data;
    }
}
exports.Directory = Directory;
class Breadcrumb {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new Breadcrumb();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}
exports.Breadcrumb = Breadcrumb;
class UserInfo {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.ownerId = data["ownerId"];
            this.name = data["name"];
            if (data["directories"] && data["directories"].constructor === Array) {
                this.directories = [];
                for (let item of data["directories"])
                    this.directories.push(Directory.fromJS(item));
            }
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(File.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId;
        data["name"] = this.name;
        if (this.directories && this.directories.constructor === Array) {
            data["directories"] = [];
            for (let item of this.directories)
                data["directories"].push(item.toJSON());
        }
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}
exports.UserInfo = UserInfo;
class PathWithId {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.path = data["path"];
            this.extension = data["extension"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new PathWithId();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["path"] = this.path;
        data["extension"] = this.extension;
        return data;
    }
}
exports.PathWithId = PathWithId;
class UploadRequestMessage {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.path = data["path"];
            this.type = data["type"];
            this.createdAt = data["createdAt"] ? new Date(data["createdAt"].toString()) : undefined;
            this.size = data["size"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UploadRequestMessage();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["type"] = this.type;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined;
        data["size"] = this.size;
        return data;
    }
}
exports.UploadRequestMessage = UploadRequestMessage;
class UploadLinkWithId {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.uploadLink = data["uploadLink"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new UploadLinkWithId();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uploadLink"] = this.uploadLink;
        return data;
    }
}
exports.UploadLinkWithId = UploadLinkWithId;
class DiskSpaceUsage {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.totalSpace = data["totalSpace"];
            this.quotaPolicy = data["quotaPolicy"];
            this.usedSpace = data["usedSpace"];
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new DiskSpaceUsage();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["totalSpace"] = this.totalSpace;
        data["quotaPolicy"] = this.quotaPolicy;
        data["usedSpace"] = this.usedSpace;
        return data;
    }
}
exports.DiskSpaceUsage = DiskSpaceUsage;
class WorkflowDefinition {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            if (data["submissions"] && data["submissions"].constructor === Array) {
                this.submissions = [];
                for (let item of data["submissions"])
                    this.submissions.push(WorkflowSubmission.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDefinition();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        if (this.submissions && this.submissions.constructor === Array) {
            data["submissions"] = [];
            for (let item of this.submissions)
                data["submissions"].push(item.toJSON());
        }
        return data;
    }
}
exports.WorkflowDefinition = WorkflowDefinition;
class WorkflowSubmission {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.workflowDefinitionId = data["workflowDefinitionId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            this.submittedAt = data["submittedAt"] ? new Date(data["submittedAt"].toString()) : undefined;
            this.completedAt = data["completedAt"] ? new Date(data["completedAt"].toString()) : undefined;
            this.state = data["state"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(WorkflowSubmissionEntry.fromJS(item));
            }
        }
    }
    static fromJS(data) {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmission();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workflowDefinitionId"] = this.workflowDefinitionId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : undefined;
        data["state"] = this.state;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data;
    }
}
exports.WorkflowSubmission = WorkflowSubmission;
var FileAccessLevel;
(function (FileAccessLevel) {
    FileAccessLevel["Public"] = "Public";
    FileAccessLevel["Authenticated"] = "Authenticated";
    FileAccessLevel["Private"] = "Private";
    FileAccessLevel["Tutor"] = "Tutor";
})(FileAccessLevel = exports.FileAccessLevel || (exports.FileAccessLevel = {}));
var WorkflowSubmissionEntryState;
(function (WorkflowSubmissionEntryState) {
    WorkflowSubmissionEntryState["Queued"] = "Queued";
    WorkflowSubmissionEntryState["Pending"] = "Pending";
    WorkflowSubmissionEntryState["Active"] = "Active";
    WorkflowSubmissionEntryState["Completed"] = "Completed";
    WorkflowSubmissionEntryState["Failed"] = "Failed";
    WorkflowSubmissionEntryState["Cancelled"] = "Cancelled";
})(WorkflowSubmissionEntryState = exports.WorkflowSubmissionEntryState || (exports.WorkflowSubmissionEntryState = {}));
var DirectoryAccessLevel;
(function (DirectoryAccessLevel) {
    DirectoryAccessLevel["Public"] = "Public";
    DirectoryAccessLevel["Authenticated"] = "Authenticated";
    DirectoryAccessLevel["Private"] = "Private";
    DirectoryAccessLevel["Tutor"] = "Tutor";
})(DirectoryAccessLevel = exports.DirectoryAccessLevel || (exports.DirectoryAccessLevel = {}));
var DiskSpaceUsageQuotaPolicy;
(function (DiskSpaceUsageQuotaPolicy) {
    DiskSpaceUsageQuotaPolicy["ManualDelete"] = "ManualDelete";
    DiskSpaceUsageQuotaPolicy["RollingBuffer"] = "RollingBuffer";
})(DiskSpaceUsageQuotaPolicy = exports.DiskSpaceUsageQuotaPolicy || (exports.DiskSpaceUsageQuotaPolicy = {}));
var WorkflowSubmissionState;
(function (WorkflowSubmissionState) {
    WorkflowSubmissionState["Queued"] = "Queued";
    WorkflowSubmissionState["Pending"] = "Pending";
    WorkflowSubmissionState["Active"] = "Active";
    WorkflowSubmissionState["Completed"] = "Completed";
    WorkflowSubmissionState["Failed"] = "Failed";
    WorkflowSubmissionState["Cancelled"] = "Cancelled";
})(WorkflowSubmissionState = exports.WorkflowSubmissionState || (exports.WorkflowSubmissionState = {}));
class SwaggerException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isSwaggerException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isSwaggerException(obj) {
        return obj.isSwaggerException === true;
    }
}
exports.SwaggerException = SwaggerException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}
//# sourceMappingURL=apiclient.js.map