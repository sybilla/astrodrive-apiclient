/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';

@inject(String, HttpClient)
export class AstroDriveApiClientV1_0 {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    apiAstrometryAttachtoentry(version: string = '1.0', entryId?: string | null | undefined, astrometry?: any | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/astrometry/attachtoentry?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(astrometry);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiAstrometryAttachtoentry(_response);
        });
    }

    protected processapiAstrometryAttachtoentry(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiDirectoryCreate(version: string = '1.0', parentId?: string | null | undefined, folderName?: string | null | undefined, path?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/directory/create?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryCreate(_response);
        });
    }

    protected processapiDirectoryCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param parentId (optional) 
     * @param archiveName (optional) 
     * @return Success
     */
    apiDirectoryCreatearchive(version: string = '1.0', id?: string | null | undefined, parentId?: string | null | undefined, archiveName?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/directory/createarchive?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (archiveName !== undefined)
            url_ += "archiveName=" + encodeURIComponent("" + archiveName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryCreatearchive(_response);
        });
    }

    protected processapiDirectoryCreatearchive(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param userId (optional) 
     * @param path (optional) 
     * @return Success
     */
    apiDirectoryList(version: string = '1.0', id?: string | null | undefined, userId?: string | null | undefined, path?: string | null | undefined): Promise<Directory> {
        let url_ = this.baseUrl + "/api/v{version}/directory/list?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryList(_response);
        });
    }

    protected processapiDirectoryList(response: Response): Promise<Directory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Directory>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param path (optional) 
     * @return Success
     */
    apiDirectoryDirectoryid(version: string = '1.0', userId?: string | null | undefined, path?: string | null | undefined): Promise<Directory> {
        let url_ = this.baseUrl + "/api/v{version}/directory/directoryid?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryDirectoryid(_response);
        });
    }

    protected processapiDirectoryDirectoryid(response: Response): Promise<Directory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Directory>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiDirectoryBreadcrumbs(version: string = '1.0', id?: string | null | undefined): Promise<Breadcrumb[]> {
        let url_ = this.baseUrl + "/api/v{version}/directory/breadcrumbs?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryBreadcrumbs(_response);
        });
    }

    protected processapiDirectoryBreadcrumbs(response: Response): Promise<Breadcrumb[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Breadcrumb.fromJS(item));
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Breadcrumb[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiDirectoryListsharedroot(version: string = '1.0'): Promise<UserInfo[]> {
        let url_ = this.baseUrl + "/api/v{version}/directory/listsharedroot";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryListsharedroot(_response);
        });
    }

    protected processapiDirectoryListsharedroot(response: Response): Promise<UserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiDirectoryListshared(version: string = '1.0', id?: string | null | undefined): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/v{version}/directory/listshared?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryListshared(_response);
        });
    }

    protected processapiDirectoryListshared(response: Response): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserInfo.fromJS(resultData200) : new UserInfo();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiDirectoryGetarchiveentries(version: string = '1.0', id?: string | null | undefined): Promise<PathWithId[]> {
        let url_ = this.baseUrl + "/api/v{version}/directory/getarchiveentries?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryGetarchiveentries(_response);
        });
    }

    protected processapiDirectoryGetarchiveentries(response: Response): Promise<PathWithId[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PathWithId.fromJS(item));
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PathWithId[]>(<any>null);
    }

    apiDirectoryUpdate(version: string = '1.0', directory?: Directory | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/directory/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(directory);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryUpdate(_response);
        });
    }

    protected processapiDirectoryUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiDirectoryRemove(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/directory/remove?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiDirectoryRemove(_response);
        });
    }

    protected processapiDirectoryRemove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param parentId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    apiFileUploadlink(version: string = '1.0', message?: UploadRequestMessage | null | undefined, parentId?: string | null | undefined, userId?: string | null | undefined): Promise<UploadLinkWithId> {
        let url_ = this.baseUrl + "/api/v{version}/file/uploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileUploadlink(_response);
        });
    }

    protected processapiFileUploadlink(response: Response): Promise<UploadLinkWithId> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadLinkWithId.fromJS(resultData200) : new UploadLinkWithId();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadLinkWithId>(<any>null);
    }

    /**
     * @param fileId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    apiFileConfirmupload(version: string = '1.0', fileId?: string | null | undefined, userId?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/file/confirmupload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileConfirmupload(_response);
        });
    }

    protected processapiFileConfirmupload(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiFileDownloadlink(version: string = '1.0', id?: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/file/downloadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileDownloadlink(_response);
        });
    }

    protected processapiFileDownloadlink(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param phrase (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @return Success
     */
    apiFileSearch(version: string = '1.0', userId?: string | null | undefined, phrase?: string | null | undefined, from?: Date | null | undefined, to?: Date | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v{version}/file/search?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (phrase !== undefined)
            url_ += "phrase=" + encodeURIComponent("" + phrase) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileSearch(_response);
        });
    }

    protected processapiFileSearch(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiFileInfo(version: string = '1.0', id?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/file/info?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileInfo(_response);
        });
    }

    protected processapiFileInfo(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiFileGetsubmissions(version: string = '1.0', id?: string | null | undefined): Promise<WorkflowSubmissionEntry[]> {
        let url_ = this.baseUrl + "/api/v{version}/file/getsubmissions?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileGetsubmissions(_response);
        });
    }

    protected processapiFileGetsubmissions(response: Response): Promise<WorkflowSubmissionEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmissionEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiFileThumbnailuploadlink(version: string = '1.0', id?: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/file/thumbnailuploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileThumbnailuploadlink(_response);
        });
    }

    protected processapiFileThumbnailuploadlink(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiFileArchiveuploadlink(version: string = '1.0', id?: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/file/archiveuploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileArchiveuploadlink(_response);
        });
    }

    protected processapiFileArchiveuploadlink(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    apiFileThumbnail(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/thumbnail?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileThumbnail(_response);
        });
    }

    protected processapiFileThumbnail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiFileArchive(version: string = '1.0', id?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/file/archive?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileArchive(_response);
        });
    }

    protected processapiFileArchive(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    apiFileArchiveprogress(version: string = '1.0', id?: string | null | undefined, processed?: number | null | undefined, total?: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/archiveprogress?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (processed !== undefined)
            url_ += "processed=" + encodeURIComponent("" + processed) + "&"; 
        if (total !== undefined)
            url_ += "total=" + encodeURIComponent("" + total) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileArchiveprogress(_response);
        });
    }

    protected processapiFileArchiveprogress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiFileAttachheader(version: string = '1.0', id?: string | null | undefined, header?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/attachheader?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(header);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileAttachheader(_response);
        });
    }

    protected processapiFileAttachheader(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiFileUpdate(version: string = '1.0', file?: File | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileUpdate(_response);
        });
    }

    protected processapiFileUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiFileDelete(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiFileDelete(_response);
        });
    }

    protected processapiFileDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param entryId (optional) 
     * @return Success
     */
    apiProgressGet(version: string = '1.0', entryId?: string | null | undefined): Promise<WorkflowSubmissionEntry> {
        let url_ = this.baseUrl + "/api/v{version}/progress/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiProgressGet(_response);
        });
    }

    protected processapiProgressGet(response: Response): Promise<WorkflowSubmissionEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmissionEntry.fromJS(resultData200) : new WorkflowSubmissionEntry();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry>(<any>null);
    }

    apiProgressLog(version: string = '1.0', entryId?: string | null | undefined, progress?: number | null | undefined, msg?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/progress/log?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        if (progress !== undefined)
            url_ += "progress=" + encodeURIComponent("" + progress) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(msg);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiProgressLog(_response);
        });
    }

    protected processapiProgressLog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiProgressError(version: string = '1.0', entryId?: string | null | undefined, msg?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/progress/error?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(msg);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiProgressError(_response);
        });
    }

    protected processapiProgressError(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param start (optional) 
     * @param count (optional) 
     * @return Success
     */
    apiUtilsLastuserimages(version: string = '1.0', start?: number | null | undefined, count?: number | null | undefined): Promise<File[]> {
        let url_ = this.baseUrl + "/api/v{version}/utils/lastuserimages?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiUtilsLastuserimages(_response);
        });
    }

    protected processapiUtilsLastuserimages(response: Response): Promise<File[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(File.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File[]>(<any>null);
    }

    /**
     * @param start (optional) 
     * @param count (optional) 
     * @return Success
     */
    apiUtilsLastimages(version: string = '1.0', start?: number | null | undefined, count?: number | null | undefined): Promise<File[]> {
        let url_ = this.baseUrl + "/api/v{version}/utils/lastimages?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiUtilsLastimages(_response);
        });
    }

    protected processapiUtilsLastimages(response: Response): Promise<File[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(File.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    apiUtilsQuota(version: string = '1.0', userId?: string | null | undefined): Promise<DiskSpaceUsage> {
        let url_ = this.baseUrl + "/api/v{version}/utils/quota?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiUtilsQuota(_response);
        });
    }

    protected processapiUtilsQuota(response: Response): Promise<DiskSpaceUsage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DiskSpaceUsage.fromJS(resultData200) : new DiskSpaceUsage();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiskSpaceUsage>(<any>null);
    }

    apiUtilsChangequota(version: string = '1.0', userId?: string | null | undefined, quotaMB?: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/utils/changequota?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (quotaMB !== undefined)
            url_ += "quotaMB=" + encodeURIComponent("" + quotaMB) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiUtilsChangequota(_response);
        });
    }

    protected processapiUtilsChangequota(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param fileId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    apiUtilsConfirmupload(version: string = '1.0', fileId?: string | null | undefined, userId?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/utils/confirmupload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiUtilsConfirmupload(_response);
        });
    }

    protected processapiUtilsConfirmupload(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param quotaMB (optional) 
     * @return Success
     */
    apiUtilsAdduser(version: string = '1.0', quotaMB?: number | null | undefined): Promise<Directory> {
        let url_ = this.baseUrl + "/api/v{version}/utils/adduser?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (quotaMB !== undefined)
            url_ += "quotaMB=" + encodeURIComponent("" + quotaMB) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiUtilsAdduser(_response);
        });
    }

    protected processapiUtilsAdduser(response: Response): Promise<Directory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Directory>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param payload (optional) 
     * @return Success
     */
    apiWorkflowdefinitionAdd(version: string = '1.0', name?: string | null | undefined, payload?: any | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/add?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionAdd(_response);
        });
    }

    protected processapiWorkflowdefinitionAdd(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param payload (optional) 
     * @return Success
     */
    apiWorkflowdefinitionAddglobal(version: string = '1.0', name?: string | null | undefined, payload?: any | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/addglobal?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionAddglobal(_response);
        });
    }

    protected processapiWorkflowdefinitionAddglobal(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowdefinitionGetbyid(version: string = '1.0', id?: string | null | undefined): Promise<WorkflowDefinition> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/getbyid?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionGetbyid(_response);
        });
    }

    protected processapiWorkflowdefinitionGetbyid(response: Response): Promise<WorkflowDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowDefinition.fromJS(resultData200) : new WorkflowDefinition();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowDefinition>(<any>null);
    }

    /**
     * @return Success
     */
    apiWorkflowdefinitionList(version: string = '1.0'): Promise<WorkflowDefinition[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/list";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionList(_response);
        });
    }

    protected processapiWorkflowdefinitionList(response: Response): Promise<WorkflowDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowDefinition.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowDefinition[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiWorkflowdefinitionListglobal(version: string = '1.0'): Promise<WorkflowDefinition[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/listglobal";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionListglobal(_response);
        });
    }

    protected processapiWorkflowdefinitionListglobal(response: Response): Promise<WorkflowDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowDefinition.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowDefinition[]>(<any>null);
    }

    /**
     * @param definition (optional) 
     * @return Success
     */
    apiWorkflowdefinitionUpdate(version: string = '1.0', definition?: WorkflowDefinition | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(definition);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionUpdate(_response);
        });
    }

    protected processapiWorkflowdefinitionUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiWorkflowdefinitionUpdateglobal(version: string = '1.0', definition?: WorkflowDefinition | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/updateglobal";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(definition);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionUpdateglobal(_response);
        });
    }

    protected processapiWorkflowdefinitionUpdateglobal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowdefinitionDelete(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionDelete(_response);
        });
    }

    protected processapiWorkflowdefinitionDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiWorkflowdefinitionDeleteglobal(version: string = '1.0', configurationId?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/deleteglobal?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (configurationId !== undefined)
            url_ += "configurationId=" + encodeURIComponent("" + configurationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowdefinitionDeleteglobal(_response);
        });
    }

    protected processapiWorkflowdefinitionDeleteglobal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param payload (optional) 
     * @return Success
     */
    apiWorkflowsubmissionSubmit(version: string = '1.0', payload?: any | null | undefined): Promise<WorkflowSubmission> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/submit";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionSubmit(_response);
        });
    }

    protected processapiWorkflowsubmissionSubmit(response: Response): Promise<WorkflowSubmission> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmission.fromJS(resultData200) : new WorkflowSubmission();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission>(<any>null);
    }

    /**
     * @return Success
     */
    apiWorkflowsubmissionListuser(version: string = '1.0'): Promise<WorkflowSubmission[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/listuser";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionListuser(_response);
        });
    }

    protected processapiWorkflowsubmissionListuser(response: Response): Promise<WorkflowSubmission[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmission.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionListworkflow(version: string = '1.0', id?: string | null | undefined): Promise<WorkflowSubmission[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/listworkflow?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionListworkflow(_response);
        });
    }

    protected processapiWorkflowsubmissionListworkflow(response: Response): Promise<WorkflowSubmission[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmission.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionGetfilesubmissionentries(version: string = '1.0', id?: string | null | undefined): Promise<WorkflowSubmissionEntry[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/getfilesubmissionentries?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionGetfilesubmissionentries(_response);
        });
    }

    protected processapiWorkflowsubmissionGetfilesubmissionentries(response: Response): Promise<WorkflowSubmissionEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmissionEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionGet(version: string = '1.0', id?: string | null | undefined): Promise<WorkflowSubmission> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionGet(_response);
        });
    }

    protected processapiWorkflowsubmissionGet(response: Response): Promise<WorkflowSubmission> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmission.fromJS(resultData200) : new WorkflowSubmission();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionEntrycancelled(version: string = '1.0', id?: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/entrycancelled?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionEntrycancelled(_response);
        });
    }

    protected processapiWorkflowsubmissionEntrycancelled(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    apiWorkflowsubmissionCancel(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/cancel?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionCancel(_response);
        });
    }

    protected processapiWorkflowsubmissionCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionentryGet(version: string = '1.0', id?: string | null | undefined): Promise<WorkflowSubmissionEntry> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionentryGet(_response);
        });
    }

    protected processapiWorkflowsubmissionentryGet(response: Response): Promise<WorkflowSubmissionEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmissionEntry.fromJS(resultData200) : new WorkflowSubmissionEntry();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionentryGetpayload(version: string = '1.0', id?: string | null | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/getpayload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionentryGetpayload(_response);
        });
    }

    protected processapiWorkflowsubmissionentryGetpayload(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiWorkflowsubmissionentryIscancelled(version: string = '1.0', id?: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/iscancelled?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionentryIscancelled(_response);
        });
    }

    protected processapiWorkflowsubmissionentryIscancelled(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    apiWorkflowsubmissionentryCancel(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/cancel?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionentryCancel(_response);
        });
    }

    protected processapiWorkflowsubmissionentryCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiWorkflowsubmissionentryDelete(version: string = '1.0', id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processapiWorkflowsubmissionentryDelete(_response);
        });
    }

    protected processapiWorkflowsubmissionentryDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class File implements IFile {
    parentDirectoryId?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    header?: string | undefined;
    accessLevel?: FileAccessLevel | undefined;
    createdDate?: Date | undefined;
    uploadedDate?: Date | undefined;
    thumbnailAddress?: string | undefined;
    extension?: string | undefined;
    uploadCompleted?: boolean | undefined;
    size?: number | undefined;
    ownerId?: string | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;
    sharedWith?: string[] | undefined;
    processedFiles?: number | undefined;
    totalFiles?: number | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;
    mD5?: string | undefined;

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentDirectoryId = data["parentDirectoryId"];
            this.id = data["id"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            this.header = data["header"];
            this.accessLevel = data["accessLevel"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.uploadedDate = data["uploadedDate"] ? new Date(data["uploadedDate"].toString()) : <any>undefined;
            this.thumbnailAddress = data["thumbnailAddress"];
            this.extension = data["extension"];
            this.uploadCompleted = data["uploadCompleted"];
            this.size = data["size"];
            this.ownerId = data["ownerId"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [] as any;
                for (let item of data["entries"])
                    this.entries!.push(WorkflowSubmissionEntry.fromJS(item));
            }
            if (data["sharedWith"] && data["sharedWith"].constructor === Array) {
                this.sharedWith = [] as any;
                for (let item of data["sharedWith"])
                    this.sharedWith!.push(item);
            }
            this.processedFiles = data["processedFiles"];
            this.totalFiles = data["totalFiles"];
            this.locked = data["locked"];
            this.lockedBy = data["lockedBy"];
            this.mD5 = data["mD5"];
        }
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentDirectoryId"] = this.parentDirectoryId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        data["header"] = this.header;
        data["accessLevel"] = this.accessLevel;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["uploadedDate"] = this.uploadedDate ? this.uploadedDate.toISOString() : <any>undefined;
        data["thumbnailAddress"] = this.thumbnailAddress;
        data["extension"] = this.extension;
        data["uploadCompleted"] = this.uploadCompleted;
        data["size"] = this.size;
        data["ownerId"] = this.ownerId;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        if (this.sharedWith && this.sharedWith.constructor === Array) {
            data["sharedWith"] = [];
            for (let item of this.sharedWith)
                data["sharedWith"].push(item);
        }
        data["processedFiles"] = this.processedFiles;
        data["totalFiles"] = this.totalFiles;
        data["locked"] = this.locked;
        data["lockedBy"] = this.lockedBy;
        data["mD5"] = this.mD5;
        return data; 
    }
}

export interface IFile {
    parentDirectoryId?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    header?: string | undefined;
    accessLevel?: FileAccessLevel | undefined;
    createdDate?: Date | undefined;
    uploadedDate?: Date | undefined;
    thumbnailAddress?: string | undefined;
    extension?: string | undefined;
    uploadCompleted?: boolean | undefined;
    size?: number | undefined;
    ownerId?: string | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;
    sharedWith?: string[] | undefined;
    processedFiles?: number | undefined;
    totalFiles?: number | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;
    mD5?: string | undefined;
}

export class WorkflowSubmissionEntry implements IWorkflowSubmissionEntry {
    id?: string | undefined;
    fileId?: string | undefined;
    workflowSubmissionId?: string | undefined;
    state?: WorkflowSubmissionEntryState | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    name?: string | undefined;
    error?: string | undefined;
    stages?: WorkflowSubmissionEntryStage[] | undefined;
    astrometries?: Astrometry[] | undefined;

    constructor(data?: IWorkflowSubmissionEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fileId = data["fileId"];
            this.workflowSubmissionId = data["workflowSubmissionId"];
            this.state = data["state"];
            this.submittedAt = data["submittedAt"] ? new Date(data["submittedAt"].toString()) : <any>undefined;
            this.completedAt = data["completedAt"] ? new Date(data["completedAt"].toString()) : <any>undefined;
            this.name = data["name"];
            this.error = data["error"];
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [] as any;
                for (let item of data["stages"])
                    this.stages!.push(WorkflowSubmissionEntryStage.fromJS(item));
            }
            if (data["astrometries"] && data["astrometries"].constructor === Array) {
                this.astrometries = [] as any;
                for (let item of data["astrometries"])
                    this.astrometries!.push(Astrometry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSubmissionEntry {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmissionEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileId"] = this.fileId;
        data["workflowSubmissionId"] = this.workflowSubmissionId;
        data["state"] = this.state;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["error"] = this.error;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        if (this.astrometries && this.astrometries.constructor === Array) {
            data["astrometries"] = [];
            for (let item of this.astrometries)
                data["astrometries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowSubmissionEntry {
    id?: string | undefined;
    fileId?: string | undefined;
    workflowSubmissionId?: string | undefined;
    state?: WorkflowSubmissionEntryState | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    name?: string | undefined;
    error?: string | undefined;
    stages?: WorkflowSubmissionEntryStage[] | undefined;
    astrometries?: Astrometry[] | undefined;
}

export class WorkflowSubmissionEntryStage implements IWorkflowSubmissionEntryStage {
    progress?: number | undefined;
    message?: string | undefined;
    timestamp?: Date | undefined;

    constructor(data?: IWorkflowSubmissionEntryStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.progress = data["progress"];
            this.message = data["message"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowSubmissionEntryStage {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmissionEntryStage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["progress"] = this.progress;
        data["message"] = this.message;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IWorkflowSubmissionEntryStage {
    progress?: number | undefined;
    message?: string | undefined;
    timestamp?: Date | undefined;
}

export class Astrometry implements IAstrometry {
    ra?: number | undefined;
    dec?: number | undefined;
    objectsCount?: number | undefined;
    rotation?: number | undefined;
    payload?: string | undefined;

    constructor(data?: IAstrometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ra = data["ra"];
            this.dec = data["dec"];
            this.objectsCount = data["objectsCount"];
            this.rotation = data["rotation"];
            this.payload = data["payload"];
        }
    }

    static fromJS(data: any): Astrometry {
        data = typeof data === 'object' ? data : {};
        let result = new Astrometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ra"] = this.ra;
        data["dec"] = this.dec;
        data["objectsCount"] = this.objectsCount;
        data["rotation"] = this.rotation;
        data["payload"] = this.payload;
        return data; 
    }
}

export interface IAstrometry {
    ra?: number | undefined;
    dec?: number | undefined;
    objectsCount?: number | undefined;
    rotation?: number | undefined;
    payload?: string | undefined;
}

export class Directory implements IDirectory {
    parentDirectoryId?: string | undefined;
    name?: string | undefined;
    accessLevel?: DirectoryAccessLevel | undefined;
    modificationDate?: Date | undefined;
    files?: File[] | undefined;
    ownerId?: string | undefined;
    id?: string | undefined;
    size?: number | undefined;
    subdirectories?: Directory[] | undefined;
    sharedWith?: string[] | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;

    constructor(data?: IDirectory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentDirectoryId = data["parentDirectoryId"];
            this.name = data["name"];
            this.accessLevel = data["accessLevel"];
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [] as any;
                for (let item of data["files"])
                    this.files!.push(File.fromJS(item));
            }
            this.ownerId = data["ownerId"];
            this.id = data["id"];
            this.size = data["size"];
            if (data["subdirectories"] && data["subdirectories"].constructor === Array) {
                this.subdirectories = [] as any;
                for (let item of data["subdirectories"])
                    this.subdirectories!.push(Directory.fromJS(item));
            }
            if (data["sharedWith"] && data["sharedWith"].constructor === Array) {
                this.sharedWith = [] as any;
                for (let item of data["sharedWith"])
                    this.sharedWith!.push(item);
            }
            this.locked = data["locked"];
            this.lockedBy = data["lockedBy"];
        }
    }

    static fromJS(data: any): Directory {
        data = typeof data === 'object' ? data : {};
        let result = new Directory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentDirectoryId"] = this.parentDirectoryId;
        data["name"] = this.name;
        data["accessLevel"] = this.accessLevel;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["ownerId"] = this.ownerId;
        data["id"] = this.id;
        data["size"] = this.size;
        if (this.subdirectories && this.subdirectories.constructor === Array) {
            data["subdirectories"] = [];
            for (let item of this.subdirectories)
                data["subdirectories"].push(item.toJSON());
        }
        if (this.sharedWith && this.sharedWith.constructor === Array) {
            data["sharedWith"] = [];
            for (let item of this.sharedWith)
                data["sharedWith"].push(item);
        }
        data["locked"] = this.locked;
        data["lockedBy"] = this.lockedBy;
        return data; 
    }
}

export interface IDirectory {
    parentDirectoryId?: string | undefined;
    name?: string | undefined;
    accessLevel?: DirectoryAccessLevel | undefined;
    modificationDate?: Date | undefined;
    files?: File[] | undefined;
    ownerId?: string | undefined;
    id?: string | undefined;
    size?: number | undefined;
    subdirectories?: Directory[] | undefined;
    sharedWith?: string[] | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;
}

export class Breadcrumb implements IBreadcrumb {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IBreadcrumb) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Breadcrumb {
        data = typeof data === 'object' ? data : {};
        let result = new Breadcrumb();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBreadcrumb {
    id?: string | undefined;
    name?: string | undefined;
}

export class UserInfo implements IUserInfo {
    ownerId?: string | undefined;
    name?: string | undefined;
    directories?: Directory[] | undefined;
    files?: File[] | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerId = data["ownerId"];
            this.name = data["name"];
            if (data["directories"] && data["directories"].constructor === Array) {
                this.directories = [] as any;
                for (let item of data["directories"])
                    this.directories!.push(Directory.fromJS(item));
            }
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [] as any;
                for (let item of data["files"])
                    this.files!.push(File.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId;
        data["name"] = this.name;
        if (this.directories && this.directories.constructor === Array) {
            data["directories"] = [];
            for (let item of this.directories)
                data["directories"].push(item.toJSON());
        }
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserInfo {
    ownerId?: string | undefined;
    name?: string | undefined;
    directories?: Directory[] | undefined;
    files?: File[] | undefined;
}

export class PathWithId implements IPathWithId {
    id?: string | undefined;
    path?: string | undefined;
    extension?: string | undefined;

    constructor(data?: IPathWithId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.path = data["path"];
            this.extension = data["extension"];
        }
    }

    static fromJS(data: any): PathWithId {
        data = typeof data === 'object' ? data : {};
        let result = new PathWithId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["path"] = this.path;
        data["extension"] = this.extension;
        return data; 
    }
}

export interface IPathWithId {
    id?: string | undefined;
    path?: string | undefined;
    extension?: string | undefined;
}

export class UploadRequestMessage implements IUploadRequestMessage {
    path?: string | undefined;
    type?: string | undefined;
    createdAt?: Date | undefined;
    size?: number | undefined;

    constructor(data?: IUploadRequestMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.path = data["path"];
            this.type = data["type"];
            this.createdAt = data["createdAt"] ? new Date(data["createdAt"].toString()) : <any>undefined;
            this.size = data["size"];
        }
    }

    static fromJS(data: any): UploadRequestMessage {
        data = typeof data === 'object' ? data : {};
        let result = new UploadRequestMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["type"] = this.type;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["size"] = this.size;
        return data; 
    }
}

export interface IUploadRequestMessage {
    path?: string | undefined;
    type?: string | undefined;
    createdAt?: Date | undefined;
    size?: number | undefined;
}

export class UploadLinkWithId implements IUploadLinkWithId {
    id?: string | undefined;
    uploadLink?: string | undefined;

    constructor(data?: IUploadLinkWithId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.uploadLink = data["uploadLink"];
        }
    }

    static fromJS(data: any): UploadLinkWithId {
        data = typeof data === 'object' ? data : {};
        let result = new UploadLinkWithId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uploadLink"] = this.uploadLink;
        return data; 
    }
}

export interface IUploadLinkWithId {
    id?: string | undefined;
    uploadLink?: string | undefined;
}

export class DiskSpaceUsage implements IDiskSpaceUsage {
    totalSpace?: number | undefined;
    quotaPolicy?: DiskSpaceUsageQuotaPolicy | undefined;
    usedSpace?: number | undefined;

    constructor(data?: IDiskSpaceUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSpace = data["totalSpace"];
            this.quotaPolicy = data["quotaPolicy"];
            this.usedSpace = data["usedSpace"];
        }
    }

    static fromJS(data: any): DiskSpaceUsage {
        data = typeof data === 'object' ? data : {};
        let result = new DiskSpaceUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSpace"] = this.totalSpace;
        data["quotaPolicy"] = this.quotaPolicy;
        data["usedSpace"] = this.usedSpace;
        return data; 
    }
}

export interface IDiskSpaceUsage {
    totalSpace?: number | undefined;
    quotaPolicy?: DiskSpaceUsageQuotaPolicy | undefined;
    usedSpace?: number | undefined;
}

export class WorkflowDefinition implements IWorkflowDefinition {
    id?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submissions?: WorkflowSubmission[] | undefined;

    constructor(data?: IWorkflowDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            if (data["submissions"] && data["submissions"].constructor === Array) {
                this.submissions = [] as any;
                for (let item of data["submissions"])
                    this.submissions!.push(WorkflowSubmission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        if (this.submissions && this.submissions.constructor === Array) {
            data["submissions"] = [];
            for (let item of this.submissions)
                data["submissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowDefinition {
    id?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submissions?: WorkflowSubmission[] | undefined;
}

export class WorkflowSubmission implements IWorkflowSubmission {
    id?: string | undefined;
    workflowDefinitionId?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    state?: WorkflowSubmissionState | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;

    constructor(data?: IWorkflowSubmission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.workflowDefinitionId = data["workflowDefinitionId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            this.submittedAt = data["submittedAt"] ? new Date(data["submittedAt"].toString()) : <any>undefined;
            this.completedAt = data["completedAt"] ? new Date(data["completedAt"].toString()) : <any>undefined;
            this.state = data["state"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [] as any;
                for (let item of data["entries"])
                    this.entries!.push(WorkflowSubmissionEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSubmission {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workflowDefinitionId"] = this.workflowDefinitionId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["state"] = this.state;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowSubmission {
    id?: string | undefined;
    workflowDefinitionId?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    state?: WorkflowSubmissionState | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;
}

export enum FileAccessLevel {
    Public = "Public", 
    Authenticated = "Authenticated", 
    Private = "Private", 
    Tutor = "Tutor", 
}

export enum WorkflowSubmissionEntryState {
    Queued = "Queued", 
    Pending = "Pending", 
    Active = "Active", 
    Completed = "Completed", 
    Failed = "Failed", 
    Cancelled = "Cancelled", 
}

export enum DirectoryAccessLevel {
    Public = "Public", 
    Authenticated = "Authenticated", 
    Private = "Private", 
    Tutor = "Tutor", 
}

export enum DiskSpaceUsageQuotaPolicy {
    ManualDelete = "ManualDelete", 
    RollingBuffer = "RollingBuffer", 
}

export enum WorkflowSubmissionState {
    Queued = "Queued", 
    Pending = "Pending", 
    Active = "Active", 
    Completed = "Completed", 
    Failed = "Failed", 
    Cancelled = "Cancelled", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}