/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { inject } from 'aurelia-framework';
import { HttpClient, RequestInit } from 'aurelia-fetch-client';

@inject(String, HttpClient)
export class ApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    apiVAstrometryAttachtoentry(version: string, entryId?: string | null | undefined, astrometry?: any | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/astrometry/attachtoentry?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(astrometry);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVAstrometryAttachtoentry(_response);
        });
    }

    protected processApiVAstrometryAttachtoentry(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVDirectoryCreate(version: string, parentId?: string | null | undefined, folderName?: string | null | undefined, path?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/directory/create?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryCreate(_response);
        });
    }

    protected processApiVDirectoryCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param parentId (optional) 
     * @param archiveName (optional) 
     * @return Success
     */
    apiVDirectoryCreatearchive(version: string, id?: string | null | undefined, parentId?: string | null | undefined, archiveName?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/directory/createarchive?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (archiveName !== undefined)
            url_ += "archiveName=" + encodeURIComponent("" + archiveName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryCreatearchive(_response);
        });
    }

    protected processApiVDirectoryCreatearchive(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param userId (optional) 
     * @param path (optional) 
     * @return Success
     */
    apiVDirectoryList(version: string, id?: string | null | undefined, userId?: string | null | undefined, path?: string | null | undefined): Promise<Directory> {
        let url_ = this.baseUrl + "/api/v{version}/directory/list?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryList(_response);
        });
    }

    protected processApiVDirectoryList(response: Response): Promise<Directory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Directory>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param path (optional) 
     * @return Success
     */
    apiVDirectoryDirectoryid(version: string, userId?: string | null | undefined, path?: string | null | undefined): Promise<Directory> {
        let url_ = this.baseUrl + "/api/v{version}/directory/directoryid?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryDirectoryid(_response);
        });
    }

    protected processApiVDirectoryDirectoryid(response: Response): Promise<Directory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Directory>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVDirectoryBreadcrumbs(version: string, id?: string | null | undefined): Promise<Breadcrumb[]> {
        let url_ = this.baseUrl + "/api/v{version}/directory/breadcrumbs?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryBreadcrumbs(_response);
        });
    }

    protected processApiVDirectoryBreadcrumbs(response: Response): Promise<Breadcrumb[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Breadcrumb.fromJS(item));
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Breadcrumb[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiVDirectoryListsharedroot(version: string): Promise<UserInfo[]> {
        let url_ = this.baseUrl + "/api/v{version}/directory/listsharedroot";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryListsharedroot(_response);
        });
    }

    protected processApiVDirectoryListsharedroot(response: Response): Promise<UserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInfo.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVDirectoryListshared(version: string, id?: string | null | undefined): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/v{version}/directory/listshared?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryListshared(_response);
        });
    }

    protected processApiVDirectoryListshared(response: Response): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserInfo.fromJS(resultData200) : new UserInfo();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVDirectoryGetarchiveentries(version: string, id?: string | null | undefined): Promise<PathWithId[]> {
        let url_ = this.baseUrl + "/api/v{version}/directory/getarchiveentries?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryGetarchiveentries(_response);
        });
    }

    protected processApiVDirectoryGetarchiveentries(response: Response): Promise<PathWithId[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PathWithId.fromJS(item));
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PathWithId[]>(<any>null);
    }

    apiVDirectoryUpdate(version: string, directory?: Directory | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/directory/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(directory);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryUpdate(_response);
        });
    }

    protected processApiVDirectoryUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVDirectoryRemove(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/directory/remove?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVDirectoryRemove(_response);
        });
    }

    protected processApiVDirectoryRemove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param parentId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    apiVFileUploadlink(version: string, message?: UploadRequestMessage | null | undefined, parentId?: string | null | undefined, userId?: string | null | undefined): Promise<UploadLinkWithId> {
        let url_ = this.baseUrl + "/api/v{version}/file/uploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileUploadlink(_response);
        });
    }

    protected processApiVFileUploadlink(response: Response): Promise<UploadLinkWithId> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadLinkWithId.fromJS(resultData200) : new UploadLinkWithId();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadLinkWithId>(<any>null);
    }

    /**
     * @param fileId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    apiVFileConfirmupload(version: string, fileId?: string | null | undefined, userId?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/file/confirmupload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileConfirmupload(_response);
        });
    }

    protected processApiVFileConfirmupload(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVFileDownloadlink(version: string, id?: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/file/downloadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileDownloadlink(_response);
        });
    }

    protected processApiVFileDownloadlink(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param phrase (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @return Success
     */
    apiVFileSearch(version: string, userId?: string | null | undefined, phrase?: string | null | undefined, from?: Date | null | undefined, to?: Date | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v{version}/file/search?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (phrase !== undefined)
            url_ += "phrase=" + encodeURIComponent("" + phrase) + "&"; 
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileSearch(_response);
        });
    }

    protected processApiVFileSearch(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVFileInfo(version: string, id?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/file/info?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileInfo(_response);
        });
    }

    protected processApiVFileInfo(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVFileGetsubmissions(version: string, id?: string | null | undefined): Promise<WorkflowSubmissionEntry[]> {
        let url_ = this.baseUrl + "/api/v{version}/file/getsubmissions?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileGetsubmissions(_response);
        });
    }

    protected processApiVFileGetsubmissions(response: Response): Promise<WorkflowSubmissionEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmissionEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVFileThumbnailuploadlink(version: string, id?: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/file/thumbnailuploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileThumbnailuploadlink(_response);
        });
    }

    protected processApiVFileThumbnailuploadlink(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVFileArchiveuploadlink(version: string, id?: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/file/archiveuploadlink?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileArchiveuploadlink(_response);
        });
    }

    protected processApiVFileArchiveuploadlink(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    apiVFileThumbnail(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/thumbnail?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileThumbnail(_response);
        });
    }

    protected processApiVFileThumbnail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVFileArchive(version: string, id?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/file/archive?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileArchive(_response);
        });
    }

    protected processApiVFileArchive(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    apiVFileArchiveprogress(version: string, id?: string | null | undefined, processed?: number | null | undefined, total?: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/archiveprogress?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (processed !== undefined)
            url_ += "processed=" + encodeURIComponent("" + processed) + "&"; 
        if (total !== undefined)
            url_ += "total=" + encodeURIComponent("" + total) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileArchiveprogress(_response);
        });
    }

    protected processApiVFileArchiveprogress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVFileAttachheader(version: string, id?: string | null | undefined, header?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/attachheader?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(header);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileAttachheader(_response);
        });
    }

    protected processApiVFileAttachheader(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVFileUpdate(version: string, file?: File | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(file);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileUpdate(_response);
        });
    }

    protected processApiVFileUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVFileDelete(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/file/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVFileDelete(_response);
        });
    }

    protected processApiVFileDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param entryId (optional) 
     * @return Success
     */
    apiVProgressGet(version: string, entryId?: string | null | undefined): Promise<WorkflowSubmissionEntry> {
        let url_ = this.baseUrl + "/api/v{version}/progress/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVProgressGet(_response);
        });
    }

    protected processApiVProgressGet(response: Response): Promise<WorkflowSubmissionEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmissionEntry.fromJS(resultData200) : new WorkflowSubmissionEntry();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry>(<any>null);
    }

    apiVProgressLog(version: string, entryId?: string | null | undefined, progress?: number | null | undefined, msg?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/progress/log?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        if (progress !== undefined)
            url_ += "progress=" + encodeURIComponent("" + progress) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(msg);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVProgressLog(_response);
        });
    }

    protected processApiVProgressLog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVProgressError(version: string, entryId?: string | null | undefined, msg?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/progress/error?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (entryId !== undefined)
            url_ += "entryId=" + encodeURIComponent("" + entryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(msg);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVProgressError(_response);
        });
    }

    protected processApiVProgressError(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param start (optional) 
     * @param count (optional) 
     * @return Success
     */
    apiVUtilsLastuserimages(version: string, start?: number | null | undefined, count?: number | null | undefined): Promise<File[]> {
        let url_ = this.baseUrl + "/api/v{version}/utils/lastuserimages?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVUtilsLastuserimages(_response);
        });
    }

    protected processApiVUtilsLastuserimages(response: Response): Promise<File[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(File.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File[]>(<any>null);
    }

    /**
     * @param start (optional) 
     * @param count (optional) 
     * @return Success
     */
    apiVUtilsLastimages(version: string, start?: number | null | undefined, count?: number | null | undefined): Promise<File[]> {
        let url_ = this.baseUrl + "/api/v{version}/utils/lastimages?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVUtilsLastimages(_response);
        });
    }

    protected processApiVUtilsLastimages(response: Response): Promise<File[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(File.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    apiVUtilsQuota(version: string, userId?: string | null | undefined): Promise<DiskSpaceUsage> {
        let url_ = this.baseUrl + "/api/v{version}/utils/quota?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVUtilsQuota(_response);
        });
    }

    protected processApiVUtilsQuota(response: Response): Promise<DiskSpaceUsage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DiskSpaceUsage.fromJS(resultData200) : new DiskSpaceUsage();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiskSpaceUsage>(<any>null);
    }

    apiVUtilsChangequota(version: string, userId?: string | null | undefined, quotaMB?: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/utils/changequota?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (quotaMB !== undefined)
            url_ += "quotaMB=" + encodeURIComponent("" + quotaMB) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVUtilsChangequota(_response);
        });
    }

    protected processApiVUtilsChangequota(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param fileId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    apiVUtilsConfirmupload(version: string, fileId?: string | null | undefined, userId?: string | null | undefined): Promise<File> {
        let url_ = this.baseUrl + "/api/v{version}/utils/confirmupload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVUtilsConfirmupload(_response);
        });
    }

    protected processApiVUtilsConfirmupload(response: Response): Promise<File> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? File.fromJS(resultData200) : new File();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<File>(<any>null);
    }

    /**
     * @param quotaMB (optional) 
     * @return Success
     */
    apiVUtilsAdduser(version: string, quotaMB?: number | null | undefined): Promise<Directory> {
        let url_ = this.baseUrl + "/api/v{version}/utils/adduser?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (quotaMB !== undefined)
            url_ += "quotaMB=" + encodeURIComponent("" + quotaMB) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVUtilsAdduser(_response);
        });
    }

    protected processApiVUtilsAdduser(response: Response): Promise<Directory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Directory.fromJS(resultData200) : new Directory();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Directory>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param payload (optional) 
     * @return Success
     */
    apiVWorkflowdefinitionAdd(version: string, name?: string | null | undefined, payload?: any | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/add?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionAdd(_response);
        });
    }

    protected processApiVWorkflowdefinitionAdd(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param payload (optional) 
     * @return Success
     */
    apiVWorkflowdefinitionAddglobal(version: string, name?: string | null | undefined, payload?: any | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/addglobal?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionAddglobal(_response);
        });
    }

    protected processApiVWorkflowdefinitionAddglobal(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowdefinitionGetbyid(version: string, id?: string | null | undefined): Promise<WorkflowDefinition> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/getbyid?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionGetbyid(_response);
        });
    }

    protected processApiVWorkflowdefinitionGetbyid(response: Response): Promise<WorkflowDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowDefinition.fromJS(resultData200) : new WorkflowDefinition();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowDefinition>(<any>null);
    }

    /**
     * @return Success
     */
    apiVWorkflowdefinitionList(version: string): Promise<WorkflowDefinition[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/list";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionList(_response);
        });
    }

    protected processApiVWorkflowdefinitionList(response: Response): Promise<WorkflowDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowDefinition.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowDefinition[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiVWorkflowdefinitionListglobal(version: string): Promise<WorkflowDefinition[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/listglobal";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionListglobal(_response);
        });
    }

    protected processApiVWorkflowdefinitionListglobal(response: Response): Promise<WorkflowDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowDefinition.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowDefinition[]>(<any>null);
    }

    /**
     * @param definition (optional) 
     * @return Success
     */
    apiVWorkflowdefinitionUpdate(version: string, definition?: WorkflowDefinition | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/update";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(definition);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionUpdate(_response);
        });
    }

    protected processApiVWorkflowdefinitionUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVWorkflowdefinitionUpdateglobal(version: string, definition?: WorkflowDefinition | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/updateglobal";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(definition);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionUpdateglobal(_response);
        });
    }

    protected processApiVWorkflowdefinitionUpdateglobal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowdefinitionDelete(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionDelete(_response);
        });
    }

    protected processApiVWorkflowdefinitionDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVWorkflowdefinitionDeleteglobal(version: string, configurationId?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowdefinition/deleteglobal?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (configurationId !== undefined)
            url_ += "configurationId=" + encodeURIComponent("" + configurationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowdefinitionDeleteglobal(_response);
        });
    }

    protected processApiVWorkflowdefinitionDeleteglobal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param payload (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionSubmit(version: string, payload?: any | null | undefined): Promise<WorkflowSubmission> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/submit";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionSubmit(_response);
        });
    }

    protected processApiVWorkflowsubmissionSubmit(response: Response): Promise<WorkflowSubmission> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmission.fromJS(resultData200) : new WorkflowSubmission();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission>(<any>null);
    }

    /**
     * @return Success
     */
    apiVWorkflowsubmissionListuser(version: string): Promise<WorkflowSubmission[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/listuser";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionListuser(_response);
        });
    }

    protected processApiVWorkflowsubmissionListuser(response: Response): Promise<WorkflowSubmission[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmission.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionListworkflow(version: string, id?: string | null | undefined): Promise<WorkflowSubmission[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/listworkflow?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionListworkflow(_response);
        });
    }

    protected processApiVWorkflowsubmissionListworkflow(response: Response): Promise<WorkflowSubmission[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmission.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionGetfilesubmissionentries(version: string, id?: string | null | undefined): Promise<WorkflowSubmissionEntry[]> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/getfilesubmissionentries?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionGetfilesubmissionentries(_response);
        });
    }

    protected processApiVWorkflowsubmissionGetfilesubmissionentries(response: Response): Promise<WorkflowSubmissionEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSubmissionEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionGet(version: string, id?: string | null | undefined): Promise<WorkflowSubmission> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionGet(_response);
        });
    }

    protected processApiVWorkflowsubmissionGet(response: Response): Promise<WorkflowSubmission> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmission.fromJS(resultData200) : new WorkflowSubmission();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmission>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionEntrycancelled(version: string, id?: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/entrycancelled?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionEntrycancelled(_response);
        });
    }

    protected processApiVWorkflowsubmissionEntrycancelled(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    apiVWorkflowsubmissionCancel(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmission/cancel?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionCancel(_response);
        });
    }

    protected processApiVWorkflowsubmissionCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionentryGet(version: string, id?: string | null | undefined): Promise<WorkflowSubmissionEntry> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/get?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionentryGet(_response);
        });
    }

    protected processApiVWorkflowsubmissionentryGet(response: Response): Promise<WorkflowSubmissionEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkflowSubmissionEntry.fromJS(resultData200) : new WorkflowSubmissionEntry();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSubmissionEntry>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionentryGetpayload(version: string, id?: string | null | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/getpayload?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionentryGetpayload(_response);
        });
    }

    protected processApiVWorkflowsubmissionentryGetpayload(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiVWorkflowsubmissionentryIscancelled(version: string, id?: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/iscancelled?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionentryIscancelled(_response);
        });
    }

    protected processApiVWorkflowsubmissionentryIscancelled(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    apiVWorkflowsubmissionentryCancel(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/cancel?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionentryCancel(_response);
        });
    }

    protected processApiVWorkflowsubmissionentryCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    apiVWorkflowsubmissionentryDelete(version: string, id?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/workflowsubmissionentry/delete?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version)); 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApiVWorkflowsubmissionentryDelete(_response);
        });
    }

    protected processApiVWorkflowsubmissionentryDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class File implements IFile {
    parentDirectoryId?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    header?: string | undefined;
    accessLevel?: FileAccessLevel | undefined;
    createdDate?: Date | undefined;
    uploadedDate?: Date | undefined;
    thumbnailAddress?: string | undefined;
    extension?: string | undefined;
    uploadCompleted?: boolean | undefined;
    size?: number | undefined;
    ownerId?: string | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;
    sharedWith?: string[] | undefined;
    processedFiles?: number | undefined;
    totalFiles?: number | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;
    mD5?: string | undefined;

    constructor(data?: IFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentDirectoryId = data["parentDirectoryId"];
            this.id = data["id"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            this.header = data["header"];
            this.accessLevel = data["accessLevel"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.uploadedDate = data["uploadedDate"] ? new Date(data["uploadedDate"].toString()) : <any>undefined;
            this.thumbnailAddress = data["thumbnailAddress"];
            this.extension = data["extension"];
            this.uploadCompleted = data["uploadCompleted"];
            this.size = data["size"];
            this.ownerId = data["ownerId"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [] as any;
                for (let item of data["entries"])
                    this.entries!.push(WorkflowSubmissionEntry.fromJS(item));
            }
            if (data["sharedWith"] && data["sharedWith"].constructor === Array) {
                this.sharedWith = [] as any;
                for (let item of data["sharedWith"])
                    this.sharedWith!.push(item);
            }
            this.processedFiles = data["processedFiles"];
            this.totalFiles = data["totalFiles"];
            this.locked = data["locked"];
            this.lockedBy = data["lockedBy"];
            this.mD5 = data["mD5"];
        }
    }

    static fromJS(data: any): File {
        data = typeof data === 'object' ? data : {};
        let result = new File();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentDirectoryId"] = this.parentDirectoryId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        data["header"] = this.header;
        data["accessLevel"] = this.accessLevel;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["uploadedDate"] = this.uploadedDate ? this.uploadedDate.toISOString() : <any>undefined;
        data["thumbnailAddress"] = this.thumbnailAddress;
        data["extension"] = this.extension;
        data["uploadCompleted"] = this.uploadCompleted;
        data["size"] = this.size;
        data["ownerId"] = this.ownerId;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        if (this.sharedWith && this.sharedWith.constructor === Array) {
            data["sharedWith"] = [];
            for (let item of this.sharedWith)
                data["sharedWith"].push(item);
        }
        data["processedFiles"] = this.processedFiles;
        data["totalFiles"] = this.totalFiles;
        data["locked"] = this.locked;
        data["lockedBy"] = this.lockedBy;
        data["mD5"] = this.mD5;
        return data; 
    }
}

export interface IFile {
    parentDirectoryId?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    header?: string | undefined;
    accessLevel?: FileAccessLevel | undefined;
    createdDate?: Date | undefined;
    uploadedDate?: Date | undefined;
    thumbnailAddress?: string | undefined;
    extension?: string | undefined;
    uploadCompleted?: boolean | undefined;
    size?: number | undefined;
    ownerId?: string | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;
    sharedWith?: string[] | undefined;
    processedFiles?: number | undefined;
    totalFiles?: number | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;
    mD5?: string | undefined;
}

export class WorkflowSubmissionEntry implements IWorkflowSubmissionEntry {
    id?: string | undefined;
    fileId?: string | undefined;
    workflowSubmissionId?: string | undefined;
    state?: WorkflowSubmissionEntryState | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    name?: string | undefined;
    error?: string | undefined;
    stages?: WorkflowSubmissionEntryStage[] | undefined;
    astrometries?: Astrometry[] | undefined;

    constructor(data?: IWorkflowSubmissionEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fileId = data["fileId"];
            this.workflowSubmissionId = data["workflowSubmissionId"];
            this.state = data["state"];
            this.submittedAt = data["submittedAt"] ? new Date(data["submittedAt"].toString()) : <any>undefined;
            this.completedAt = data["completedAt"] ? new Date(data["completedAt"].toString()) : <any>undefined;
            this.name = data["name"];
            this.error = data["error"];
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [] as any;
                for (let item of data["stages"])
                    this.stages!.push(WorkflowSubmissionEntryStage.fromJS(item));
            }
            if (data["astrometries"] && data["astrometries"].constructor === Array) {
                this.astrometries = [] as any;
                for (let item of data["astrometries"])
                    this.astrometries!.push(Astrometry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSubmissionEntry {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmissionEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileId"] = this.fileId;
        data["workflowSubmissionId"] = this.workflowSubmissionId;
        data["state"] = this.state;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["error"] = this.error;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        if (this.astrometries && this.astrometries.constructor === Array) {
            data["astrometries"] = [];
            for (let item of this.astrometries)
                data["astrometries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowSubmissionEntry {
    id?: string | undefined;
    fileId?: string | undefined;
    workflowSubmissionId?: string | undefined;
    state?: WorkflowSubmissionEntryState | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    name?: string | undefined;
    error?: string | undefined;
    stages?: WorkflowSubmissionEntryStage[] | undefined;
    astrometries?: Astrometry[] | undefined;
}

export class WorkflowSubmissionEntryStage implements IWorkflowSubmissionEntryStage {
    progress?: number | undefined;
    message?: string | undefined;
    timestamp?: Date | undefined;

    constructor(data?: IWorkflowSubmissionEntryStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.progress = data["progress"];
            this.message = data["message"];
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowSubmissionEntryStage {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmissionEntryStage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["progress"] = this.progress;
        data["message"] = this.message;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IWorkflowSubmissionEntryStage {
    progress?: number | undefined;
    message?: string | undefined;
    timestamp?: Date | undefined;
}

export class Astrometry implements IAstrometry {
    ra?: number | undefined;
    dec?: number | undefined;
    objectsCount?: number | undefined;
    rotation?: number | undefined;
    payload?: string | undefined;

    constructor(data?: IAstrometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ra = data["ra"];
            this.dec = data["dec"];
            this.objectsCount = data["objectsCount"];
            this.rotation = data["rotation"];
            this.payload = data["payload"];
        }
    }

    static fromJS(data: any): Astrometry {
        data = typeof data === 'object' ? data : {};
        let result = new Astrometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ra"] = this.ra;
        data["dec"] = this.dec;
        data["objectsCount"] = this.objectsCount;
        data["rotation"] = this.rotation;
        data["payload"] = this.payload;
        return data; 
    }
}

export interface IAstrometry {
    ra?: number | undefined;
    dec?: number | undefined;
    objectsCount?: number | undefined;
    rotation?: number | undefined;
    payload?: string | undefined;
}

export class Directory implements IDirectory {
    parentDirectoryId?: string | undefined;
    name?: string | undefined;
    accessLevel?: DirectoryAccessLevel | undefined;
    modificationDate?: Date | undefined;
    files?: File[] | undefined;
    ownerId?: string | undefined;
    id?: string | undefined;
    size?: number | undefined;
    subdirectories?: Directory[] | undefined;
    sharedWith?: string[] | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;

    constructor(data?: IDirectory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentDirectoryId = data["parentDirectoryId"];
            this.name = data["name"];
            this.accessLevel = data["accessLevel"];
            this.modificationDate = data["modificationDate"] ? new Date(data["modificationDate"].toString()) : <any>undefined;
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [] as any;
                for (let item of data["files"])
                    this.files!.push(File.fromJS(item));
            }
            this.ownerId = data["ownerId"];
            this.id = data["id"];
            this.size = data["size"];
            if (data["subdirectories"] && data["subdirectories"].constructor === Array) {
                this.subdirectories = [] as any;
                for (let item of data["subdirectories"])
                    this.subdirectories!.push(Directory.fromJS(item));
            }
            if (data["sharedWith"] && data["sharedWith"].constructor === Array) {
                this.sharedWith = [] as any;
                for (let item of data["sharedWith"])
                    this.sharedWith!.push(item);
            }
            this.locked = data["locked"];
            this.lockedBy = data["lockedBy"];
        }
    }

    static fromJS(data: any): Directory {
        data = typeof data === 'object' ? data : {};
        let result = new Directory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentDirectoryId"] = this.parentDirectoryId;
        data["name"] = this.name;
        data["accessLevel"] = this.accessLevel;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["ownerId"] = this.ownerId;
        data["id"] = this.id;
        data["size"] = this.size;
        if (this.subdirectories && this.subdirectories.constructor === Array) {
            data["subdirectories"] = [];
            for (let item of this.subdirectories)
                data["subdirectories"].push(item.toJSON());
        }
        if (this.sharedWith && this.sharedWith.constructor === Array) {
            data["sharedWith"] = [];
            for (let item of this.sharedWith)
                data["sharedWith"].push(item);
        }
        data["locked"] = this.locked;
        data["lockedBy"] = this.lockedBy;
        return data; 
    }
}

export interface IDirectory {
    parentDirectoryId?: string | undefined;
    name?: string | undefined;
    accessLevel?: DirectoryAccessLevel | undefined;
    modificationDate?: Date | undefined;
    files?: File[] | undefined;
    ownerId?: string | undefined;
    id?: string | undefined;
    size?: number | undefined;
    subdirectories?: Directory[] | undefined;
    sharedWith?: string[] | undefined;
    locked?: boolean | undefined;
    lockedBy?: string | undefined;
}

export class Breadcrumb implements IBreadcrumb {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IBreadcrumb) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Breadcrumb {
        data = typeof data === 'object' ? data : {};
        let result = new Breadcrumb();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBreadcrumb {
    id?: string | undefined;
    name?: string | undefined;
}

export class UserInfo implements IUserInfo {
    ownerId?: string | undefined;
    name?: string | undefined;
    directories?: Directory[] | undefined;
    files?: File[] | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerId = data["ownerId"];
            this.name = data["name"];
            if (data["directories"] && data["directories"].constructor === Array) {
                this.directories = [] as any;
                for (let item of data["directories"])
                    this.directories!.push(Directory.fromJS(item));
            }
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [] as any;
                for (let item of data["files"])
                    this.files!.push(File.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerId"] = this.ownerId;
        data["name"] = this.name;
        if (this.directories && this.directories.constructor === Array) {
            data["directories"] = [];
            for (let item of this.directories)
                data["directories"].push(item.toJSON());
        }
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserInfo {
    ownerId?: string | undefined;
    name?: string | undefined;
    directories?: Directory[] | undefined;
    files?: File[] | undefined;
}

export class PathWithId implements IPathWithId {
    id?: string | undefined;
    path?: string | undefined;
    extension?: string | undefined;

    constructor(data?: IPathWithId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.path = data["path"];
            this.extension = data["extension"];
        }
    }

    static fromJS(data: any): PathWithId {
        data = typeof data === 'object' ? data : {};
        let result = new PathWithId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["path"] = this.path;
        data["extension"] = this.extension;
        return data; 
    }
}

export interface IPathWithId {
    id?: string | undefined;
    path?: string | undefined;
    extension?: string | undefined;
}

export class UploadRequestMessage implements IUploadRequestMessage {
    path?: string | undefined;
    type?: string | undefined;
    createdAt?: Date | undefined;
    size?: number | undefined;

    constructor(data?: IUploadRequestMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.path = data["path"];
            this.type = data["type"];
            this.createdAt = data["createdAt"] ? new Date(data["createdAt"].toString()) : <any>undefined;
            this.size = data["size"];
        }
    }

    static fromJS(data: any): UploadRequestMessage {
        data = typeof data === 'object' ? data : {};
        let result = new UploadRequestMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["type"] = this.type;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["size"] = this.size;
        return data; 
    }
}

export interface IUploadRequestMessage {
    path?: string | undefined;
    type?: string | undefined;
    createdAt?: Date | undefined;
    size?: number | undefined;
}

export class UploadLinkWithId implements IUploadLinkWithId {
    id?: string | undefined;
    uploadLink?: string | undefined;

    constructor(data?: IUploadLinkWithId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.uploadLink = data["uploadLink"];
        }
    }

    static fromJS(data: any): UploadLinkWithId {
        data = typeof data === 'object' ? data : {};
        let result = new UploadLinkWithId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uploadLink"] = this.uploadLink;
        return data; 
    }
}

export interface IUploadLinkWithId {
    id?: string | undefined;
    uploadLink?: string | undefined;
}

export class DiskSpaceUsage implements IDiskSpaceUsage {
    totalSpace?: number | undefined;
    quotaPolicy?: DiskSpaceUsageQuotaPolicy | undefined;
    usedSpace?: number | undefined;

    constructor(data?: IDiskSpaceUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSpace = data["totalSpace"];
            this.quotaPolicy = data["quotaPolicy"];
            this.usedSpace = data["usedSpace"];
        }
    }

    static fromJS(data: any): DiskSpaceUsage {
        data = typeof data === 'object' ? data : {};
        let result = new DiskSpaceUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSpace"] = this.totalSpace;
        data["quotaPolicy"] = this.quotaPolicy;
        data["usedSpace"] = this.usedSpace;
        return data; 
    }
}

export interface IDiskSpaceUsage {
    totalSpace?: number | undefined;
    quotaPolicy?: DiskSpaceUsageQuotaPolicy | undefined;
    usedSpace?: number | undefined;
}

export class WorkflowDefinition implements IWorkflowDefinition {
    id?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submissions?: WorkflowSubmission[] | undefined;

    constructor(data?: IWorkflowDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            if (data["submissions"] && data["submissions"].constructor === Array) {
                this.submissions = [] as any;
                for (let item of data["submissions"])
                    this.submissions!.push(WorkflowSubmission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        if (this.submissions && this.submissions.constructor === Array) {
            data["submissions"] = [];
            for (let item of this.submissions)
                data["submissions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowDefinition {
    id?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submissions?: WorkflowSubmission[] | undefined;
}

export class WorkflowSubmission implements IWorkflowSubmission {
    id?: string | undefined;
    workflowDefinitionId?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    state?: WorkflowSubmissionState | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;

    constructor(data?: IWorkflowSubmission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.workflowDefinitionId = data["workflowDefinitionId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.configuration = data["configuration"];
            this.submittedAt = data["submittedAt"] ? new Date(data["submittedAt"].toString()) : <any>undefined;
            this.completedAt = data["completedAt"] ? new Date(data["completedAt"].toString()) : <any>undefined;
            this.state = data["state"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [] as any;
                for (let item of data["entries"])
                    this.entries!.push(WorkflowSubmissionEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSubmission {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSubmission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workflowDefinitionId"] = this.workflowDefinitionId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["configuration"] = this.configuration;
        data["submittedAt"] = this.submittedAt ? this.submittedAt.toISOString() : <any>undefined;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        data["state"] = this.state;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowSubmission {
    id?: string | undefined;
    workflowDefinitionId?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    configuration?: string | undefined;
    submittedAt?: Date | undefined;
    completedAt?: Date | undefined;
    state?: WorkflowSubmissionState | undefined;
    entries?: WorkflowSubmissionEntry[] | undefined;
}

export enum FileAccessLevel {
    Public = "Public", 
    Authenticated = "Authenticated", 
    Private = "Private", 
    Tutor = "Tutor", 
}

export enum WorkflowSubmissionEntryState {
    Queued = "Queued", 
    Pending = "Pending", 
    Active = "Active", 
    Completed = "Completed", 
    Failed = "Failed", 
    Cancelled = "Cancelled", 
}

export enum DirectoryAccessLevel {
    Public = "Public", 
    Authenticated = "Authenticated", 
    Private = "Private", 
    Tutor = "Tutor", 
}

export enum DiskSpaceUsageQuotaPolicy {
    ManualDelete = "ManualDelete", 
    RollingBuffer = "RollingBuffer", 
}

export enum WorkflowSubmissionState {
    Queued = "Queued", 
    Pending = "Pending", 
    Active = "Active", 
    Completed = "Completed", 
    Failed = "Failed", 
    Cancelled = "Cancelled", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}